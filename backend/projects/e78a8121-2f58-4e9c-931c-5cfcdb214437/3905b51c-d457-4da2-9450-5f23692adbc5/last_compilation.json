{
  "success": true,
  "timestamp": "2025-08-22T13:50:02.794Z",
  "compilation_time": 2343,
  "code_snapshot": "module counter::counter {\n    use iota::object::{Self, UID};\n    use iota::tx_context::{Self, TxContext};\n    use iota::transfer;\n    use iota::event;\n\n    /// Error codes\n    const ECounterOverflow: u64 = 0;\n    const ECounterUnderflow: u64 = 1;\n    const ENotOwner: u64 = 2;\n\n    /// Counter object that maintains a count value\n    public struct Counter has key, store {\n        id: UID,\n        value: u64,\n        owner: address,\n    }\n\n    /// Event emitted when counter value changes\n    public struct CounterUpdated has copy, drop {\n        old_value: u64,\n        new_value: u64,\n        action: vector<u8>, // \"increment\", \"decrement\", \"reset\", etc.\n    }\n\n    /// Create a new counter with an initial value\n    public entry fun create_counter(\n        initial_value: u64, \n        ctx: &mut TxContext\n    ) {\n        let counter = Counter {\n            id: object::new(ctx),\n            value: initial_value,\n            owner: tx_context::sender(ctx),\n        };\n        \n        // Transfer ownership to the creator\n        transfer::public_transfer(counter, tx_context::sender(ctx));\n    }\n\n    /// Create a shared counter that anyone can interact with\n    public entry fun create_shared_counter(\n        initial_value: u64,\n        ctx: &mut TxContext\n    ) {\n        let counter = Counter {\n            id: object::new(ctx),\n            value: initial_value,\n            owner: @0x0, // No specific owner for shared counter\n        };\n        \n        // Make it a shared object\n        transfer::public_share_object(counter);\n    }\n\n    /// Increment the counter by 1\n    public entry fun increment(counter: &mut Counter) {\n        let old_value = counter.value;\n        \n        // Check for overflow\n        assert!(counter.value < 18446744073709551615, ECounterOverflow);\n        counter.value = counter.value + 1;\n        \n        // Emit event\n        event::emit(CounterUpdated {\n            old_value,\n            new_value: counter.value,\n            action: b\"increment\",\n        });\n    }\n    \n    /// Increment the counter by a specific amount\n    public entry fun increment_by(counter: &mut Counter, amount: u64) {\n        let old_value = counter.value;\n        \n        // Check for overflow\n        assert!(counter.value <= 18446744073709551615 - amount, ECounterOverflow);\n        counter.value = counter.value + amount;\n        \n        event::emit(CounterUpdated {\n            old_value,\n            new_value: counter.value,\n            action: b\"increment_by\",\n        });\n    }\n    \n    /// Decrement the counter by 1\n    public entry fun decrement(counter: &mut Counter) {\n        let old_value = counter.value;\n        \n        // Check for underflow\n        assert!(counter.value > 0, ECounterUnderflow);\n        counter.value = counter.value - 1;\n        \n        event::emit(CounterUpdated {\n            old_value,\n            new_value: counter.value,\n            action: b\"decrement\",\n        });\n    }\n    \n    /// Reset the counter to zero\n    public entry fun reset(counter: &mut Counter, ctx: &mut TxContext) {\n        // Only owner can reset (if not shared)\n        if (counter.owner != @0x0) {\n            assert!(counter.owner == tx_context::sender(ctx), ENotOwner);\n        };\n        \n        let old_value = counter.value;\n        counter.value = 0;\n        \n        event::emit(CounterUpdated {\n            old_value,\n            new_value: 0,\n            action: b\"reset\",\n        });\n    }\n    \n    /// Get the current counter value (view function)\n    public fun get_value(counter: &Counter): u64 {\n        counter.value\n    }\n    \n    /// Check if an address is the owner\n    public fun is_owner(counter: &Counter, addr: address): bool {\n        counter.owner == addr\n    }\n}"
}